import "hashes/sha256/sha256"
/* Requires application-specific parameters: 
 *numBlocks (i.e., jwtLengthInBits % 512 hopefully this is constant and there isn't much variability in JWT length!)
 * aud (e.g., byte representation of ","*/
def checkJwt<N,A,S>(private u32[N][16] paddedJwt, u32[8] jwtHash, private u32[N][16] maskAud, private u32[N][16] maskSub, private u32[N][16] maskExp, private u32[A] paddedAud, private u32[S] paddedSub, private u32 exp, u32 expGreaterThan) -> bool: //allow JWT up to 512 bits
  // Check that preimage is valid
  assert(sha256(paddedJwt) == jwtHash)
  // Loop through padded jwt and get the aud, sub, and exp claims
  field audPosition = 0
  field subPosition = 0
  field expPosition = 0
  u32[N][16] aud = [[0; 16]; N]
   for u32 i in 0..N do
     for u32 j in 0..16 do
        u32 audMasked = maskAud[i][j] & paddedJwt[i][j]
        u32 subMasked = maskSub[i][j] & paddedJwt[i][j]
        u32 expMasked = maskExp[i][j] & paddedJwt[i][j]
        // If the value hasn't started and the position is still 0, keep the position at 0. Otherwise, increment the position
        audPosition = (audMasked == 0) && (audPosition == 0) ? 0 : audPosition + 1
        subPosition = (subMasked == 0) && (subPosition == 0) ? 0 : subPosition + 1
        expPosition = (expMasked == 0) && (expPosition == 0) ? 0 : subPosition + 1
        
    endfor
   endfor
  return true


// [1][16] : here, N = 1. can do any N, e.g., [19][16] iff all inputs are of same length
def main(private u32[1][16] paddedJwt, u32[8] jwtHash, private u32[1][16] maskAud, private u32[1][16] maskSub, private u32[1][16] maskExp, private u32[4] paddedAud, private u32[2] paddedSub, private u32 exp, u32 expGreaterThan) -> bool:
    return checkJwt(paddedJwt, jwtHash, maskAud, maskSub, maskExp, paddedAud, paddedSub, exp, expGreaterThan)