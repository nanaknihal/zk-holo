import "hashes/sha256/sha256"
/* Requires application-specific parameters: 
 *numBlocks (i.e., jwtLengthInBits % 512 hopefully this is constant and there isn't much variability in JWT length!)
 * aud (e.g., byte representation of ","*/
def checkJwt<N,A,S>(private u32[N][16] paddedJwt, u32[8] jwtHash, u32[N][16] maskAud, private u32[N][16] maskSub, private u32[N][16] maskExp, private u32[A] paddedAud, private u32[S] paddedSub, private u32 exp, u32 expGreaterThan) -> bool: //allow JWT up to 512 bits
  // Check that preimage is valid
  assert(sha256(paddedJwt) == jwtHash)
  // Loop through padded jwt and get the aud, sub, and exp claims
  u32 audPosition = 0
  bool audEquals = true // Is initializing these to true unsafe to certain attacks?
  u32 subPosition = 0
  bool subEquals = true // TODO : figure out how to check sub ends with something such a ", or @opsci.io". For public JWTs, i suppose this can be checked in solidity though
  u32 expPosition = 0
  bool expEquals = true
  u32[N][16] aud = [[0; 16]; N]
   for u32 i in 0..N do
     for u32 j in 0..16 do
        u32 audMasked = maskAud[i][j] & paddedJwt[i][j]
        u32 subMasked = maskSub[i][j] & paddedJwt[i][j]
        u32 expMasked = maskExp[i][j] & paddedJwt[i][j]
        // If the value hasn't started and the position is still 0, keep the position at 0. Otherwise, increment the position
        audPosition = ((audMasked == 0) && (audPosition == 0)) ? 0 : (audPosition + 1)
        subPosition = ((subMasked == 0) && (subPosition == 0)) ? 0 : (subPosition + 1)
        expPosition = ((expMasked == 0) && (expPosition == 0) )? 0 : (expPosition + 1)
        // Note that position is one-indexed; it is 0 before the aud/sub/exp starts and 1 for the aud/sub/exp's first byte
        audEquals = (audPosition < A) ? (audEquals && (audMasked == paddedAud[audPosition])) : audEquals
        subEquals = (subPosition < S) ? (subEquals && (subMasked == paddedSub[subPosition])) : subEquals
        expEquals = (expPosition == 1) ? (expMasked == exp) : expEquals
        
    endfor
   endfor
  return true


// [1][16] : here, N = 1. can do any N, e.g., [19][16] iff all inputs are of same length
def main(private u32[1][16] paddedJwt, u32[8] jwtHash, u32[1][16] maskAud, private u32[1][16] maskSub, private u32[1][16] maskExp, private u32[4] paddedAud, private u32[2] paddedSub, private u32 exp, u32 expGreaterThan) -> bool:
    return checkJwt(paddedJwt, jwtHash, maskAud, maskSub, maskExp, paddedAud, paddedSub, exp, expGreaterThan)