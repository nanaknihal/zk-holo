import "hashes/sha256/sha256"
// import "utils/casts/u32_array_to_bool_array" as u32ArrToBoolArr
from "EMBED" import u32_to_bits as u32ToBits

// TODO : unit test all functions and integration main

// NOTE : HUGE constraint number when this is executed
def hasSubstringAt<F,S>(bool[F] fullString, bool[S] subString, u32 idx) -> bool:
	bool[S] r = [false; S]
  for u32 i in 0..S do
		r[i] = fullString[idx+i]
	endfor
  return (r == subString)

def maskString<L>(bool[L] str, bool[L] mask) -> bool:
	// bool[S] r = fullString[idx..idx+S]
	return true //(r == subString)

// Check that a mask for a continuous string: it is a string of optional 0 bits followed by a string 1 bits, optionally followed by a series of x bits. In other words, mask[i] xor mask[i+1] should only be 1 in at most 2 places
def checkMask<M>(bool[M] mask) -> bool:
  u32 nChanges = 0
  for u32 i in 1..M do
    nChanges = (mask[i-1] != mask[i]) ? nChanges+1 : nChanges
  endfor
  return ((nChanges == 0) || (nChanges == 1) || (nChanges == 2))
    

// Check that a mask is a series of 1s followed by a series of 0s
// this only works for some types of masks requires more constraints. Thus, it should be deprecated
// def checkMask2<M>(private bool[M] mask, private u32 numOnes) -> bool:
//   bool validMask = true // Problem initializing this as true if input is length 0 or execution terminates early (i don't think early termination is possible nor would input length be accepted as 0)?
//   bool doneWithOnes = false
//   for u32 i in 0..M do
//     doneWithOnes = doneWithOnes || (!mask[i])
//     validMask = validMask && (doneWithOnes ? (!mask[i]) : (mask[i]) )
//   endfor
//   return validMask

def checkExp<N>(private u32[N][16] paddedJwt, u32 expGreaterThan, private u32[2] expIdx):
  assert(paddedJwt[expIdx[0]][expIdx[1]] > expGreaterThan)
  return

def checkAud<F,A>(private bool[F] flattenedJwt, bool[A] aud, u32 audIdx) -> bool:
  assert(hasSubstringAt(flattenedJwt, aud, audIdx))
  return true

def checkSub<F,S>(private bool[F] flattenedJwt, bool[S] paddedSub, bool[S] subMask, u32 subIdx, u32 onesInSubMask) -> bool:
  assert(checkMask(subMask))
  bool[S] maskedSection = [false; S]
  for u32 i in 0..S do
    maskedSection[i] = flattenedJwt[subIdx+i] && subMask[i]
  endfor
  assert(maskedSection == subMask)
  return true

def checkJwt<N,A,S>(private u32[N][16] paddedJwt, u32[8] jwtHash, private bool[A] aud, private u32 audIdx, private bool[S] paddedSub, u32 subIdx, private bool[S] subMask, private u32 onesInSubMask, u32 expGreaterThan, private u32[2] expIdx) -> bool: //allow JWT up to 512 bits
  // Check that preimage is valid
  assert(sha256(paddedJwt) == jwtHash)
  // Loop through padded jwt and get the aud, sub, and exp claims

  // Flatten the input (should it be separate function for unit testing?)
  //u32[N*16] flattened = [0; N*16]
  bool[N*512] flattened = [false; 512]
  u32 iTimes16 = 0
  u32 iTimes16TimesJTimes32 = 0
  for u32 i in 0..N do
    iTimes16 = i * 16
    for u32 j in 0..16 do
      iTimes16TimesJTimes32 = iTimes16 * j * 32
      bool[32] newBytes = u32ToBits(paddedJwt[i][j])
      for u32 k in 0..32 do
        flattened[iTimes16TimesJTimes32+k] = newBytes[k]
      endfor
    endfor
  endfor

  // This costs 150k constraints
  // bool abc = checkAud(flattened, aud, audIdx)
  // bool bcd = checkSub(flattened, paddedSub, subMask, subIdx, onesInSubMask)
  // NOTE : This is destructive; it changes flattened

  assert(checkMask(subMask)) 
  // assert(checkMask2(subMask, onesInSubMask))



  //assert(hasSubstringAt(flattened, padded))

  // u32 audPosition = 0
  // bool audEquals = true // Is initializing these to true unsafe to certain attacks?
  // u32 subPosition = 0
  // bool subEquals = true // TODO : figure out how to check sub ends with something such a ", or @opsci.io". For public JWTs, i suppose this can be checked in solidity though
  // u32 expPosition = 0
  // bool expEquals = true
  // u32[N][16] aud = [[0; 16]; N]
  //  for u32 i in 0..N do
  //    for u32 j in 0..16 do
  //       u32 audMasked = maskAud[i][j] & paddedJwt[i][j]
  //       u32 subMasked = maskSub[i][j] & paddedJwt[i][j]
  //       u32 expMasked = maskExp[i][j] & paddedJwt[i][j]
  //       // If the value hasn't started and the position is still 0, keep the position at 0. Otherwise, increment the position
  //       audPosition = ((audMasked == 0) && (audPosition == 0)) ? 0 : (audPosition + 1)
  //       subPosition = ((subMasked == 0) && (subPosition == 0)) ? 0 : (subPosition + 1)
  //       expPosition = ((expMasked == 0) && (expPosition == 0) )? 0 : (expPosition + 1)
  //       // Note that position is one-indexed; it is 0 before the aud/sub/exp starts and 1 for the aud/sub/exp's first byte
  //       audEquals = (audPosition < A) ? (audEquals && (audMasked == paddedAud[audPosition])) : audEquals
  //       subEquals = (subPosition < S) ? (subEquals && (subMasked == paddedSub[subPosition])) : subEquals
  //       expEquals = (expPosition == 1) ? (expMasked == exp) : expEquals
        
  //   endfor
  //  endfor
  return true


def main(private u32[1][16] paddedJwt, u32[8] jwtHash, private bool[139] aud, private u32 audIdx, private bool[512] paddedSub, private u32 subIdx, private bool[512] subMask, private u32 onesInSubMask, u32 expGreaterThan, private u32[2] expIdx) -> bool:
    return checkJwt(paddedJwt, jwtHash, aud, audIdx, paddedSub, subIdx, subMask, onesInSubMask, expGreaterThan, expIdx)