import "hashes/sha256/sha256"
from "EMBED" import u8_from_bits as u8FromBits
from "EMBED" import u32_to_bits as u32ToBits

// TODO : unit test all functions and integration main

def substringAt<F,S>(u8[F] fullString, u32 idx) -> u8[S]:
	u8[S] r = [0; S]
  for u32 i in 0..S do
    r[i] = fullString[idx + i]
	endfor
  return r

  
def hasSubstringAt<F,S>(u8[F] fullString, u8[S] subString, u32 idx) -> bool:
	u8[S] r = substringAt(fullString, idx)
  return (r == subString)


def maskString<L>(u8[L] str, u8[L] mask) -> u8[L]:
	u8[L] masked = [0; L]
  for u32 i in 0..L do
    masked[i] = mask[i] & str[i]
  endfor
	return masked //(r == subString)


// Checks masks, but where bytes are the unit of information, and bytes are set to all 1 or all 0
def checkMask<M>(u8[M] mask) -> bool:
  u32 nChanges = 0
  bool valid = ((mask[0] != 255) || (mask[0] != 0)) // Track whether all bytes are 255 or 0
  for u32 i in 1..M do
    nChanges = (mask[i-1] != mask[i]) ? nChanges+1 : nChanges
    valid = valid && ((mask[i] != 255) || (mask[i] != 0))
  endfor
  return valid && ((nChanges == 1) || (nChanges == 2))


def checkAud<F,A>(u8[F] flattened, u8[A] aud, u32 audIdx) -> bool:
  return hasSubstringAt(flattened, aud, audIdx)


def checkExp<N>(u32[N][16] paddedJwt, u32 expGreaterThan, u32[2] expIdx) -> bool:
  return paddedJwt[expIdx[0]][expIdx[1]] > expGreaterThan


// @param {extendedSub} the sub claim, plus the following extra characters up to length S for padding as inputs must be of fixed length
// @param {subMask} since we don't want to reveal anything after sub, the mask is provided to mask sub with 1s and other bits with 0s
// @param {maskedSub} this can be made public -- this is the sub claim followed by 0s until length S
// @param {subIdx} this is where the the sub starts in flattened
def checkSub<F,S>(u8[F] flattened, u8[S] extendedSub, u8[S] subMask, u8[S] maskedSub, u32 subIdx) -> bool:
  return ((maskString(extendedSub, subMask) == maskedSub) && checkMask(subMask) && hasSubstringAt(flattened, extendedSub, subIdx))

// Flatten a N*16 array of u32 to a 1-dimensional array of bytes
def flattenedToBytes<N,F>(u32[N][16] nBy16Arr) -> u8[F]:
  u8[N*128] flattened = [0; 128]
  u32 iTimes16 = 0
  // u32 iTimes16TimesJTimes8 = 0
  for u32 i in 0..N do
    iTimes16 = i * 16
    for u32 j in 0..16 do
      // iTimes16TimesJTimes8 = iTimes16 * j * 8
      bool[32] newBits = u32ToBits(nBy16Arr[i][j])
      flattened[iTimes16] = u8FromBits(newBits[0..8])  
      flattened[iTimes16+8] = u8FromBits(newBits[8..16])
      flattened[iTimes16+16] = u8FromBits(newBits[16..24])  
      flattened[iTimes16+24] = u8FromBits(newBits[24..32])        
    endfor
  endfor
  return flattened


// Wrap everything together to check a JWT
def checkJwt<N,A,S>(u32[N][16] paddedJwt, u32[8] jwtHash, u8[A] aud, u32 audIdx, u8[S] extendedSub, u8[S] maskedSub, u32 subIdx, private u8[S] subMask, private u32 onesInSubMask, u32 expGreaterThan, private u32[2] expIdx) -> bool: //allow JWT up to 512 bits
  // Check that preimage is valid
  assert(sha256(paddedJwt) == jwtHash)

  // Flatten to bytes to search for aud, sub, and exp substring
  u8[N*128] flattened = flattenedToBytes(paddedJwt)

  
  return checkAud(flattened, aud, audIdx) && checkSub(flattened, extendedSub, subMask, maskedSub, subIdx) && checkExp(paddedJwt, expGreaterThan, expIdx)



def main(private u32[1][16] paddedJwt, u32[8] jwtHash, private u8[17] aud, private u32 audIdx, private u8[64] extendedSub, u8[64] maskedSub, private u32 subIdx, private u8[64] subMask, private u32 onesInSubMask, u32 expGreaterThan, private u32[2] expIdx) -> bool:
    return checkJwt(paddedJwt, jwtHash, aud, audIdx, extendedSub, maskedSub, subIdx, subMask, onesInSubMask, expGreaterThan, expIdx)