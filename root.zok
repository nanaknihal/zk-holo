import "hashes/sha256/sha256"
/* Requires application-specific parameters: 
 *numBlocks (i.e., jwtLengthInBits % 512 hopefully this is constant and there isn't much variability in JWT length!)
 * aud (e.g., byte representation of ","*/

// TODO : unit test all functions and integration main
def hasSubstringAt<N,S>(u32[N] fullString, u32[S] subString, u32 idx):
	// for u32 i in 1..S do
	// 	r[i] = fullString[idx + i]
	// endfor
	
	u32[S] r = fullString[idx..idx+S]
	assert(r == subString)
	return

// Check that a mask is a series of 1s followed by a series of 0s
def checkMask<M>(private bool[M] mask, private u32 numOnes):
  bool validMask = true // Problem initializing this as true if input is length 0 or execution terminates early (i don't think early termination is possible nor would input length be accepted as 0)?
  bool doneWithOnes = false
  for u32 i in 0..M do
    doneWithOnes = doneWithOnes || (!mask[i])
    validMask = validMask && (doneWithOnes ? (!mask[i]) : (mask[i]) )
  endfor
  assert(validMask)
  return
  
def checkJwt<N,A,S>(private u32[N][16] paddedJwt, u32[8] jwtHash, private u8[A] aud, private u32 audIdx, private u8[S] paddedSub, u32 subIdx, private u8[S] subMask, private u32 subMaskOneIdx, u32 expGreaterThan, private u32[1][1] expIdx) -> bool: //allow JWT up to 512 bits
  // Check that preimage is valid
  assert(sha256(paddedJwt) == jwtHash)
  // Loop through padded jwt and get the aud, sub, and exp claims

  // Flatten the input (should it be separate function for unit testing?)
  u32[16*N] flattened = [0; N * 16]
  u32 iTimes16 = 0
  for u32 i in 0..N do
    iTimes16 = i * 16
    for u32 j in 0..16 do
      flattened[iTimes16+j] = paddedJwt[i][j]
    endfor
  endfor

  //assert(hasSubstringAt(flattened, padded))

  // u32 audPosition = 0
  // bool audEquals = true // Is initializing these to true unsafe to certain attacks?
  // u32 subPosition = 0
  // bool subEquals = true // TODO : figure out how to check sub ends with something such a ", or @opsci.io". For public JWTs, i suppose this can be checked in solidity though
  // u32 expPosition = 0
  // bool expEquals = true
  // u32[N][16] aud = [[0; 16]; N]
  //  for u32 i in 0..N do
  //    for u32 j in 0..16 do
  //       u32 audMasked = maskAud[i][j] & paddedJwt[i][j]
  //       u32 subMasked = maskSub[i][j] & paddedJwt[i][j]
  //       u32 expMasked = maskExp[i][j] & paddedJwt[i][j]
  //       // If the value hasn't started and the position is still 0, keep the position at 0. Otherwise, increment the position
  //       audPosition = ((audMasked == 0) && (audPosition == 0)) ? 0 : (audPosition + 1)
  //       subPosition = ((subMasked == 0) && (subPosition == 0)) ? 0 : (subPosition + 1)
  //       expPosition = ((expMasked == 0) && (expPosition == 0) )? 0 : (expPosition + 1)
  //       // Note that position is one-indexed; it is 0 before the aud/sub/exp starts and 1 for the aud/sub/exp's first byte
  //       audEquals = (audPosition < A) ? (audEquals && (audMasked == paddedAud[audPosition])) : audEquals
  //       subEquals = (subPosition < S) ? (subEquals && (subMasked == paddedSub[subPosition])) : subEquals
  //       expEquals = (expPosition == 1) ? (expMasked == exp) : expEquals
        
  //   endfor
  //  endfor
  return true


def main(private u32[1][16] paddedJwt, u32[8] jwtHash, private u8[11] aud, private u32 audIdx, private u8[64] paddedSub, private u32 subIdx, private u8[64] subMask, private u32 subMaskOneIdx, u32 expGreaterThan, private u32[1][1] expIdx) -> bool:
    return checkJwt(paddedJwt, jwtHash, aud, audIdx, paddedSub, subIdx, subMask, subMaskOneIdx, expGreaterThan, expIdx)