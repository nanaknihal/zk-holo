from "./base64" import fromBase64;
from "./utils" import decimalStringToField, unflatten, flatten, substringAt, bool_array_to_u8_array, u8_array_to_bool_array;
from "EMBED" import u32_to_bits as u32ToBits;
from "EMBED" import u32_from_bits as u32FromBits;
from "EMBED" import u8_to_bits as u8ToBits;
from "EMBED" import u8_from_bits as u8FromBits;
import "hashes/sha256/sha256" as sha256;
import "hashes/blake2/blake2s" as macHash;


const u32 SUB_START_LENGTH = 8;
const u32 SUB_END_LENGTH = 3;
const u32 SUB_MIDDLE_LENGTH = 19;
const u32 SUB_LENGTH = SUB_START_LENGTH + SUB_END_LENGTH + SUB_MIDDLE_LENGTH;
const u32 SUB_SECRET_LENGTH = 64 - SUB_MIDDLE_LENGTH; // Length of sub claim, including SUB_START and SUB_END. SHOULD NOT BE LESS THAN 16 BYTES FOR SECURE RANDOMNESS
// assert(SUB_SECRET_LENGTH > 15);

// const u8[SUB_START_LENGTH] SUB_START = [ 0x22, 0x63, 0x72, 0x65, 0x64, 0x73, 0x22, 0x3a, 0x22 ];
const u8[SUB_START_LENGTH] SUB_START = [ 0x2c, 0x22, 0x73, 0x75, 0x62, 0x22, 0x3a, 0x22 ]; // U8 representation of `,"sub":"`
const u8[SUB_END_LENGTH] SUB_END = [ 0x22, 0x2c, 0x22 ]; // U8 representation of `","`

const u32 EXP_START_LENGTH = 8;
const u32 EXP_END_LENGTH = 3;
const u32 EXP_MIDDLE_LENGTH = 10;
const u32 EXP_LENGTH = EXP_START_LENGTH + EXP_END_LENGTH + EXP_MIDDLE_LENGTH; 

const u8[EXP_START_LENGTH] EXP_START = [ 0x22, 0x2c, 0x22, 0x65, 0x78, 0x70, 0x22, 0x3a ];
const u8[EXP_END_LENGTH] EXP_END = [ 0x22, 0x2c, 0x22 ]; // U8 representation of `","`

const u32 AUD_LENGTH = 3;
const u8[AUD_LENGTH] AUD = [1, 2, 3]; //fix this // U8 representation of 

const u32 JWT_BLOCKS = 3; // represents length of padded JWT (base64 JWT with periods, header and payload, no signature) in 512-byte multiples 
const u32 JWT_NUMBITS_PLAINTEXT = JWT_BLOCKS * 384; // how many bits a JWT is in plaintext

// Verifies a JWT
def main(private u32[JWT_BLOCKS][16] paddedJwt, u32[8] jwtDigest, u32[8] subCommitment, private u8[SUB_SECRET_LENGTH] subSecret, private u32 subIdx, private u32 audIdx, field expGreaterThan, private u32 expIdx) {
  // Flatten to bytes to search for aud, sub, and exp substring
  u8[JWT_BLOCKS*64] flattened = flatten(paddedJwt);
  // Convert from base64 to string search for aud, sub, and exp substring
  u8[JWT_BLOCKS*48] plaintext = fromBase64(flattened);
  // Shift string by two bits to account for . offset between header and payload. This will make the header undecipherable but allow the payload to be deciphered
  bool[JWT_NUMBITS_PLAINTEXT] boolified = u8_array_to_bool_array(plaintext);
  bool[JWT_NUMBITS_PLAINTEXT] shifted = [...boolified[2..JWT_NUMBITS_PLAINTEXT], false, false];
  u8[JWT_BLOCKS*48] asStr = bool_array_to_u8_array(shifted);

  // Check that JWT contains valid sub
  u8[SUB_START_LENGTH]  proposedSubStart   = substringAt(asStr, subIdx);
  u8[SUB_MIDDLE_LENGTH] proposedSubMiddle  = substringAt(asStr, subIdx + SUB_START_LENGTH);
  u8[SUB_END_LENGTH]    proposedSubEnd     = substringAt(asStr, subIdx + SUB_START_LENGTH + SUB_MIDDLE_LENGTH);

  assert(proposedSubStart == SUB_START);
  assert(proposedSubEnd == SUB_END);
  assert(macHash(unflatten::<64,1>([...proposedSubMiddle, ...subSecret])) == subCommitment);

  // Check that JWT contains valid aud
  u8[AUD_LENGTH] proposedAud = substringAt(asStr, audIdx);
  assert(proposedAud == AUD);

  // Check that JWT contains valid exp
  u8[EXP_START_LENGTH]  proposedExpStart  = substringAt(asStr, expIdx);
  u8[EXP_MIDDLE_LENGTH] proposedExpMiddle = substringAt(asStr, expIdx + EXP_START_LENGTH);
  u8[EXP_END_LENGTH]    proposedExpEnd    = substringAt(asStr, expIdx + EXP_START_LENGTH+EXP_MIDDLE_LENGTH);
  assert(proposedExpStart == EXP_START);
  assert(proposedExpEnd == EXP_END);
  assert(decimalStringToField(proposedExpMiddle) > expGreaterThan);

  // Check that JWT hashes to jwtDigest
  assert(sha256(paddedJwt) == jwtDigest);
  
  
  

  return;
}

