from "./base64" import fromBase64;
from "./utils" import flatten;
from "./utils" import unFlatten;
from "EMBED" import u32_to_bits as u32ToBits;
from "EMBED" import u32_from_bits as u32FromBits;
from "EMBED" import u8_to_bits as u8ToBits;
from "EMBED" import u8_from_bits as u8FromBits;
import "hashes/sha256/sha256" as sha256;
import "hashes/blake2/blake2s" as macHash;

const u32 SUB_LENGTH = 30; // Length of sub claim, including SUB_START and SUB_END. SHOULD NOT BE MORE THAN 48, OTHERWISE RECONSIDER THIS DESIGN (NEED TO LEAVE 16 BYTES FOR SECURE RANDOMNESS)
const u32 SUB_SECRET_LENGTH = 64 - SUB_LENGTH;
// assert(SUB_SECRET_LENGTH > 15);
const u8[8] SUB_START = [ 44, 34, 15, 17, 98, 34, 58, 34]; // U8 representation of `,"sub":"`
const u8[3] SUB_END = [34, 44, 34]; // U8 representation of `","`
// const u8[] AUD = []; // U8 representation of 

def verifyJWT<N>(private u32[N][16] paddedJwt, u32[8] jwtHash, private u32 subIdx, private u32[SUB_SECRET_LENGTH] subSecret, u32[8] subCommitment, private u32 expIdx, u32 expGreaterThan) {
  // Flatten to bytes to search for aud, sub, and exp substring
  u8[N*128] flattened = flattenedToBytes(paddedJwt);
  u8[SUB_LENGTH] sub = substringAt(flattened, subIdx);
  // checkAud(flattened, aud, audIdx);
  assert(sha256(paddedJwt) == jwtHash);

//   assert(macHash([...sub]));
  return;
}

